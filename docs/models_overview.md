# PRISM Models & Geometric Engines

> **Prism Research** – A unified geometric model of equilibrium.

This document explains the core engines used by PRISM:
what they do, how they work mathematically, what data they accept,
and how to use them in practice.

It is intentionally written for researchers in fields like
**finance, climate science, engineering, and complex systems**, so that
you can reuse the ideas on your own data.

---

## 1. Wavelet Coherence Engine

**Type:** Time–frequency geometry
**Typical module:** `analysis/wavelet_coherence.py` (or equivalent)

### Concept

Wavelet coherence measures **how strongly two time series move together**
as a function of both **time** and **frequency (scale)**.
It is like a correlation that can "zoom in" on specific horizons
(short-term vs long-term).

### Inputs

- Time–aligned series (e.g. daily returns) for ≥ 2 indicators
- Regular sampling (daily / weekly)
- Minimum length ≈ 3 × largest wavelet scale used

### Outputs

- Coherence surface \( C(t, s) \in [0, 1] \)
- Aggregate coherence time series (for each window)
- High-coherence periods used as **regime-change candidates**

### Uses in PRISM

- Detect when **many indicators synchronize**, a precursor to regime shifts
- Feed coherence scores into **consensus** and **MRF** style metrics
- Compare to dispersion and network measures as cross-checks

---

## 2. Hidden Markov Model (HMM) Regime Engine

**Type:** Unsupervised machine learning (temporal)
**Typical module:** `analysis/hmm_regime.py`

### Concept

An HMM assumes that observed returns are generated by **latent states**
(e.g. calm, stressed, crisis). It learns:

- the probability of being in each state at each time, and
- the transition probabilities between states.

No labels are required – this is **unsupervised**.

### Inputs

- Feature panel (returns, vol, spreads, etc.)
- Daily time step recommended
- Number of hidden states (2–4 is common)

### Outputs

- \( P(S_t = k \mid \text{data}) \) for each time \( t \)
- Most likely regime path {state_t}
- Transition matrix between regimes

### Uses in PRISM

- Provide **regime labels** that can be compared with:
  - GMM clustering,
  - wavelet coherence events,
  - PCA geometry shifts
- Provide inputs to **MRF / tactical tilt** logic
- Study regime persistence and transition risk

---

## 3. PCA Geometry Engine

**Type:** Dimensionality reduction / factor geometry
**Typical module:** `analysis/pca_geometry.py`

### Concept

Principal Component Analysis (PCA) finds the **axes of maximal variance**
in the indicator panel, enabling PRISM to work in a low-dimensional
"risk space" while preserving most of the structure.

### Inputs

- Normalized indicator panel (often returns)
- Rolling windows (e.g. 63, 126, 252 days)
- Choice of number of components (e.g. 3–5)

### Outputs

- Eigenvalues / explained variance
- Eigenvectors / factor loadings
- Coordinates of each indicator in PCA space

### Uses in PRISM

- Track when risk **concentrates** into a few dominant components
- Detect **geometry changes** (rotations, spreads)
- Support MRF and other composite scores via factor-level analysis

---

## 4. Gaussian Mixture (GMM) Clustering Engine

**Type:** Unsupervised machine learning (cross-sectional)
**Typical module:** `analysis/gmm_regime.py`

### Concept

A Gaussian Mixture Model approximates the distribution of returns
as a mixture of a few Gaussian "blobs" (clusters). Each blob can be
interpreted as a **regime** or **market condition**.

### Inputs

- Feature matrix of returns / risk metrics
- Number of clusters or model selection range (BIC/AIC)
- Optional PCA pre-projection

### Outputs

- Cluster assignment probabilities per observation
- Cluster means and covariances
- Regime labels aligned with dates

### Uses in PRISM

- Alternative regime detection compared to HMM
- Check **stability of regimes** under different features
- Compare regime boundaries with major macro events

---

## 5. Network / Graph Geometry Engine

**Type:** Graph / topology
**Typical module:** `analysis/network_geometry.py`

### Concept

Treat indicators as **nodes** in a graph, and connect them based on
correlation or distance. Study how the **network structure** evolves:
central hubs, clustering, fragmentation.

### Inputs

- Correlation (or distance) matrix between indicators
- Threshold or K-nearest neighbor rule
- Rolling windows

### Outputs

- Degree, centrality, clustering coefficients
- Connected components / communities
- Network-based early-warning summary metrics

### Uses in PRISM

- Identify **key risk hubs** (high centrality)
- Detect **fragmentation** vs **synchronization**
- Cross-check coherence and dispersion signals

---

## 6. Dispersion & Volatility Geometry Engine

**Type:** Cross-sectional risk geometry
**Typical module:** `analysis/dispersion_engine.py`

### Concept

Measures how **spread out** returns are across indicators (and vs a
benchmark). High dispersion often precedes or accompanies regime shifts.

### Inputs

- Panel of indicator returns
- Optional benchmark (e.g. S&P 500)
- Rolling window size

### Outputs

- Cross-sectional standard deviation and robust metrics
- Sector/style dispersion aggregates
- Time-series of dispersion scores

### Uses in PRISM

- Detect early warning of **breakdowns in breadth**
- Measure whether rallies/selloffs are **narrow or broad**
- Feed dispersion into ML/Meta composite lenses

---

## 7. Data Formats & Panel Requirements

Most engines expect data in one of two forms:

### 7.1 Time Series Table

```text
date,indicator,value
2020-01-02,sp500,3257.85
2020-01-02,vix,14.02
...
```

### 7.2 Wide Panel

```text
date,sp500,vix,t10y2y,usd_index,...
2020-01-02,3257.85,14.02,0.25,96.7,...
2020-01-03,3264.33,13.95,0.26,96.8,...
```

PRISM's internal pipeline handles:

- Fetch → raw tables
- Normalize / clean → wide panels
- Engine-ready panels (returns, z-scores, etc.)

External users can reuse the models with any data that can be mapped
into this structure (finance, climate, biology, etc.).

---

## 8. Running the Full Pipeline

For a step-by-step guide from clone to dashboard, see the
**Quickstart for Researchers** section in the main `README.md`.
